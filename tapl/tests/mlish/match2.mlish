#lang s-exp "../../mlish.rkt"
(require "../rackunit-typechecking.rkt")

;; alternate match that supports nested patterns

(define-type (Test X)
  (A X)
  (B (× X X))
  (C (× X (× X X))))

(check-type
  (match2 (B (tup 2 3)) with
   [(B x) -> x]) : (× Int Int) -> (list 2 3))

(check-type
  (match2 (A (tup 2 3)) with
   [(A x) -> x]) : (× Int Int) -> (list 2 3))

(check-type
  (match2 (A 1) with
   [(A x) -> x]) : Int -> 1)

(typecheck-fail
  (match2 (B 1) with
   [(B x) -> x]) 
  #:with-msg "Could not infer instantiation of polymorphic function B")

(check-type
  (match2 (B (tup 2 3)) with
   [(B (tup x y)) -> (+ x y)]) : Int -> 5)

(check-type
  (match2 (C (tup 2 (tup 3 4))) with
   [(C (tup x (tup y z))) -> (+ x (+ y z))]) : Int -> 9)

(check-type
  (match2 (C (tup 2 (tup 3 4))) with
   [(A x) -> x]
   [_ -> 100]) : Int -> 100)



;; lists

(check-type
  (match2 (list 1) with
   [(list x) -> x]) : Int -> 1)

(check-type
  (match2 (list 1 2) with
   [(list x y) -> (+ x y)]) : Int -> 3)

(check-type
  (match2 (list 1 2) with
   [(list) -> 0]
   [(list x y) -> (+ x y)]) : Int -> 3)

(check-type
  (match2 (list (list 3 4) (list 5 6)) with
   [(list) -> 0]
   [(list (list w x) (list y z)) -> (+ (+ x y) (+ z w))]) : Int -> 18)

(check-type
  (match2 (list (tup 3 4) (tup 5 6)) with
   [(list) -> 0]
   [(list (tup w x) (tup y z)) -> (+ (+ x y) (+ z w))]) : Int -> 18)

#;(check-type
  (match2 (nil {Int}) with
   [nil -> 0]
   [(list x y) -> (+ x y)]) : Int -> 0)
