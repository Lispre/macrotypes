2015-05-28
Problem: how to represent \forall types
1) (Racket) functions
- this gets the most linguistic reuse (is this true?)
- but this does not allow equality comparisons
- unless perhaps compare two foralls for equality by applying to the same tvar
  - but these type vars would be unbound so it still wouldnt work without
    adding a new special case
2) syntax
- easier to compare
- but still need to manually implement alpha equality
- would still require a special case for comparing the bodies, which have
  unbound typevars

Problem: begin in lambda body gets spliced
- results in combined syntax properties, eg types
Solution: 
- wrap lambda body with #%expression to indicate expression, ie non-splicing,
  begin

2015-05-29
Notes: locally-nameless representation of lambdas (and other binding terms)
- syntactically distinguishes bound names vs free vars
- combination of debruijn (nameless) for bound vars and names
- simplifies implementation of capture avoiding substitution
  - I already get around by using Racket's identifiers and free-identifier=
    to easily implement capture-avoiding subst
- debruijn indices for boundvars avoids having to convert to canonical form
  to compare for alpha-equal
- using names for free vars avoids "shifting" of indices when adding or 
  removing binders, ie free vars dont rely on context
- two main operations:
  - open: converts some bound vars to free vars
    - eg subst into lambda body
    - conversion and subst can be done in one pass?
  - close: converts some free vars to bound vars 
    - eg wrapping a term in a lambda
    - similar to subst
  - both operations involve traversing the term
    - but can do straight-subst (instead of renaming subst) because
      shadowing is not possible
- multiple binders are more complicated
  - require both depth and offset index

Previous: -----------------

macro system requirements:
- depth-first expansion, i.e., localexpand, and stop-lists
- language form hooks, e.g., #%app, etc
- literal types, e.g. integer syntax class, ie compile time literal type tag
- identifiers and free-identifier=?
- syntax-parse or other pattern matching

Type constructors must be prefix (and not infix) and must be functions
- because in order to support type aliases:
  - types must be expanded,
  - and having a macro identifier (ie, an alias) in the function position
    makes the expander error (constructor is ok bc it is run time identifier)

Type expansion problem: what to do about #%app?
1) use the #%app in scope: 
  - may do type checking and error bc types dont have types
2) use the racket #%app:
  - may work but how to do this without ruining context of other
   identifiers (ie types)
Solution: do #1, but
1) stop at the #%app
2) manually drop it and continue expanding rest

Types must be identifiers, but not macros
- cannot be macros if we want to use expansion for type aliases
  - because then what does a base type like Int expand to?
  - if we define Int as a runtime identifier, then expansion will stop at Int


debugging notes -------------
- "datum" error:

?: literal data is not allowed;
 no #%datum syntax transformer is bound in: #f

  - likely indicates use of wrong version of some overloaded form
    - eg, using stlc:lambda instead of racket's lambda

- vague "bad syntax" error
  - means a syntax-parse #:when or #:with matching failed
  - ideally would have better err msg at that spot
